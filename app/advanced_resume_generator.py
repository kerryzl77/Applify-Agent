"""
Advanced Resume Generation System
================================

Multi-Agent LLM-Powered Resume Optimization (2025)
Implements Google-level engineering standards for ATS-optimized, 
job-specific resume generation using 5 specialized AI agents.

Features:
- Multi-agent AI framework (5 LLM calls)
- Advanced job-specific tailoring
- Real-time ATS optimization scoring
- Context-aware content generation
- One-page format optimization
- Keyword density analysis
"""

import os
import json
import time
import logging
from typing import Dict, List, Any, Optional, Tuple
from dataclasses import dataclass
from openai import OpenAI
import re
from datetime import datetime

@dataclass
class ResumeMetrics:
    """Advanced metrics for resume optimization."""
    ats_score: int = 0
    keyword_match_score: int = 0
    content_quality_score: int = 0
    format_compliance_score: int = 0
    job_relevance_score: int = 0
    estimated_word_count: int = 0
    one_page_compliance: bool = False
    improvement_areas: List[str] = None
    strengths: List[str] = None
    
    def __post_init__(self):
        if self.improvement_areas is None:
            self.improvement_areas = []
        if self.strengths is None:
            self.strengths = []

@dataclass
class JobAnalysis:
    """Comprehensive job analysis results."""
    job_title: str = ""
    industry: str = ""
    company_size: str = ""
    seniority_level: str = ""
    required_skills: List[str] = None
    preferred_skills: List[str] = None
    technical_keywords: List[str] = None
    soft_skills: List[str] = None
    qualifications: List[str] = None
    responsibilities: List[str] = None
    company_values: List[str] = None
    salary_range: str = ""
    location_type: str = ""
    urgency_indicators: List[str] = None
    growth_opportunities: List[str] = None
    
    def __post_init__(self):
        for field in ['required_skills', 'preferred_skills', 'technical_keywords', 
                     'soft_skills', 'qualifications', 'responsibilities', 
                     'company_values', 'urgency_indicators', 'growth_opportunities']:
            if getattr(self, field) is None:
                setattr(self, field, [])

class AdvancedResumeGenerator:
    """
    Enterprise-grade resume generation system using 5 specialized AI agents.
    
    Agent Architecture:
    1. Job Intelligence Agent - Deep job description analysis
    2. Resume Analysis Agent - Comprehensive resume evaluation
    3. Content Optimization Agent - Generate tailored content
    4. ATS Compliance Agent - Ensure ATS compatibility
    5. Quality Assurance Agent - Final review and optimization
    """
    
    def __init__(self, api_key: str = None):
        self.client = OpenAI(api_key=api_key or os.getenv("OPENAI_API_KEY"))
        self.model = "gpt-4o"
        self.temperature = 0.3
        
        # Performance tracking
        self.generation_start_time = None
        self.agent_timings = {}
        
        # ATS 2025 Standards
        self.ats_standards = {
            'max_word_count': 600,
            'required_sections': ['summary', 'experience', 'skills', 'education'],
            'optimal_keyword_density': {'min': 65, 'max': 85},
            'font_standards': ['Arial', 'Calibri', 'Times New Roman'],
            'max_bullets_per_job': 3,
            'max_experience_entries': 4,
            'summary_word_range': (40, 80),
            'skills_categories': ['Technical Skills', 'Tools & Technologies', 'Soft Skills']
        }
        
        logging.basicConfig(level=logging.INFO)
        self.logger = logging.getLogger(__name__)
    
    def generate_optimized_resume(self, candidate_data: Dict, job_description: str, 
                                 progress_callback=None) -> Tuple[Dict, ResumeMetrics]:
        """
        Generate ATS-optimized, job-tailored resume using 5 AI agents.
        
        Returns:
            Tuple[optimized_resume_data, performance_metrics]
        """
        self.generation_start_time = time.time()
        
        try:
            # Agent 1: Job Intelligence Analysis
            if progress_callback:
                progress_callback("job_analysis", 15, "ðŸ§  AI Agent 1: Analyzing job requirements...")
            
            job_analysis = self._job_intelligence_agent(job_description)
            
            # Agent 2: Resume Analysis
            if progress_callback:
                progress_callback("resume_analysis", 30, "ðŸ“Š AI Agent 2: Evaluating current resume...")
            
            resume_analysis = self._resume_analysis_agent(candidate_data, job_analysis)
            
            # Agent 3: Content Optimization
            if progress_callback:
                progress_callback("content_optimization", 50, "âœ¨ AI Agent 3: Generating optimized content...")
            
            optimized_content = self._content_optimization_agent(
                candidate_data, job_analysis, resume_analysis
            )
            
            # Agent 4: ATS Compliance Check
            if progress_callback:
                progress_callback("ats_optimization", 75, "ðŸŽ¯ AI Agent 4: Ensuring ATS compatibility...")
            
            ats_optimized_content = self._ats_compliance_agent(
                optimized_content, job_analysis
            )
            
            # Agent 5: Quality Assurance
            if progress_callback:
                progress_callback("quality_assurance", 90, "ðŸ” AI Agent 5: Final quality review...")
            
            final_resume, metrics = self._quality_assurance_agent(
                ats_optimized_content, job_analysis, candidate_data
            )
            
            # Calculate final metrics
            total_time = time.time() - self.generation_start_time
            self.logger.info(f"âœ… Resume generation completed in {total_time:.2f}s")
            
            metrics.ats_score = self._calculate_final_ats_score(final_resume, job_analysis)
            
            return final_resume, metrics
            
        except Exception as e:
            self.logger.error(f"Resume generation failed: {str(e)}")
            raise\n    \n    def _job_intelligence_agent(self, job_description: str) -> JobAnalysis:\n        """Agent 1: Deep job description analysis with industry intelligence."""\n        start_time = time.time()\n        \n        prompt = f"""\n        You are a Senior Job Market Intelligence Analyst with expertise in ATS systems and hiring trends.\n        \n        Analyze this job description with Google-level precision and extract comprehensive intelligence:\n        \n        Job Description:\n        {job_description}\n        \n        Provide a detailed JSON analysis with these fields:\n        {{\n            "job_title": "Exact job title",\n            "industry": "Specific industry/sector",\n            "company_size": "startup/small/medium/large/enterprise",\n            "seniority_level": "entry/mid/senior/executive",\n            "required_skills": ["skill1", "skill2", ...],\n            "preferred_skills": ["skill1", "skill2", ...],\n            "technical_keywords": ["keyword1", "keyword2", ...],\n            "soft_skills": ["skill1", "skill2", ...],\n            "qualifications": ["qualification1", "qualification2", ...],\n            "responsibilities": ["responsibility1", "responsibility2", ...],\n            "company_values": ["value1", "value2", ...],\n            "salary_range": "estimated range if mentioned",\n            "location_type": "remote/hybrid/onsite",\n            "urgency_indicators": ["urgent", "immediate", "asap", ...],\n            "growth_opportunities": ["opportunity1", "opportunity2", ...]\n        }}\n        \n        Focus on:\n        - Exact keyword extraction for ATS optimization\n        - Hidden requirements between the lines\n        - Company culture signals\n        - Growth trajectory indicators\n        - Technical depth requirements\n        \n        Return ONLY valid JSON.\n        """\n        \n        try:\n            response = self.client.chat.completions.create(\n                model=self.model,\n                messages=[\n                    {"role": "system", "content": "You are an elite job market intelligence analyst. Extract precise, ATS-optimized job insights. Return only valid JSON."},\n                    {"role": "user", "content": prompt}\n                ],\n                temperature=self.temperature,\n                timeout=45\n            )\n            \n            analysis_data = self._parse_json_response(response.choices[0].message.content)\n            \n            # Convert to JobAnalysis dataclass\n            job_analysis = JobAnalysis(**analysis_data)\n            \n            self.agent_timings['job_intelligence'] = time.time() - start_time\n            self.logger.info(f"ðŸ§  Job Intelligence Analysis: {job_analysis.job_title} ({job_analysis.seniority_level} level)")\n            \n            return job_analysis\n            \n        except Exception as e:\n            self.logger.error(f"Job Intelligence Agent failed: {str(e)}")\n            # Return fallback analysis\n            return JobAnalysis(\n                job_title="Professional Role",\n                industry="Technology",\n                seniority_level="mid",\n                required_skills=["Professional Skills"],\n                technical_keywords=["Technology", "Leadership"]\n            )\n    \n    def _resume_analysis_agent(self, candidate_data: Dict, job_analysis: JobAnalysis) -> Dict:\n        """Agent 2: Comprehensive resume analysis with gap identification."""\n        start_time = time.time()\n        \n        resume_data = candidate_data.get('resume', {})\n        \n        prompt = f"""\n        You are a Senior Resume Analyst specializing in ATS optimization and job matching.\n        \n        Analyze this resume against the target job with forensic precision:\n        \n        Target Job Analysis:\n        {json.dumps(job_analysis.__dict__, indent=2)}\n        \n        Current Resume Data:\n        {json.dumps(resume_data, indent=2)}\n        \n        Provide comprehensive analysis in JSON format:\n        {{\n            "current_strengths": ["strength1", "strength2", ...],\n            "critical_gaps": ["gap1", "gap2", ...],\n            "keyword_gaps": ["missing_keyword1", "missing_keyword2", ...],\n            "experience_relevance": "high/medium/low",\n            "skills_alignment": "excellent/good/poor",\n            "achievements_quality": "quantified/descriptive/weak",\n            "content_optimization_needs": {{\n                "summary": "needs_rewrite/needs_improvement/good",\n                "experience": "major_revision/minor_revision/good",\n                "skills": "complete_overhaul/reorganization/good",\n                "education": "enhancement/good/irrelevant"\n            }},\n            "ats_risk_factors": ["factor1", "factor2", ...],\n            "competitive_advantages": ["advantage1", "advantage2", ...],\n            "improvement_priority": ["highest_priority", "medium_priority", "low_priority"],\n            "estimated_job_match_score": 85,\n            "content_gaps": {{\n                "missing_technical_skills": ["skill1", "skill2"],\n                "missing_soft_skills": ["skill1", "skill2"],\n                "missing_achievements": ["type1", "type2"],\n                "missing_keywords": ["keyword1", "keyword2"]\n            }}\n        }}\n        \n        Analysis Focus:\n        - ATS keyword matching precision\n        - Content quality and quantification\n        - Competitive positioning\n        - Gap analysis for job requirements\n        - Achievement impact assessment\n        \n        Return ONLY valid JSON.\n        """\n        \n        try:\n            response = self.client.chat.completions.create(\n                model=self.model,\n                messages=[\n                    {"role": "system", "content": "You are an elite resume analyst. Provide precise, actionable insights for ATS optimization. Return only valid JSON."},\n                    {"role": "user", "content": prompt}\n                ],\n                temperature=self.temperature,\n                timeout=45\n            )\n            \n            analysis = self._parse_json_response(response.choices[0].message.content)\n            \n            self.agent_timings['resume_analysis'] = time.time() - start_time\n            self.logger.info(f"ðŸ“Š Resume Analysis: {analysis.get('estimated_job_match_score', 0)}/100 match score")\n            \n            return analysis\n            \n        except Exception as e:\n            self.logger.error(f"Resume Analysis Agent failed: {str(e)}")\n            return {\n                "current_strengths": [],\n                "critical_gaps": [],\n                "estimated_job_match_score": 70,\n                "experience_relevance": "medium"\n            }\n    \n    def _content_optimization_agent(self, candidate_data: Dict, job_analysis: JobAnalysis, \n                                   resume_analysis: Dict) -> Dict:\n        """Agent 3: Generate optimized content for each resume section."""\n        start_time = time.time()\n        \n        # Generate each section with specialized prompts\n        sections = {}\n        \n        # Professional Summary\n        sections['professional_summary'] = self._generate_optimized_summary(\n            candidate_data, job_analysis, resume_analysis\n        )\n        \n        # Skills Section\n        sections['skills'] = self._generate_optimized_skills(\n            candidate_data, job_analysis, resume_analysis\n        )\n        \n        # Experience Section\n        sections['experience'] = self._generate_optimized_experience(\n            candidate_data, job_analysis, resume_analysis\n        )\n        \n        # Education Section\n        sections['education'] = self._generate_optimized_education(\n            candidate_data, job_analysis\n        )\n        \n        self.agent_timings['content_optimization'] = time.time() - start_time\n        self.logger.info("âœ¨ Content Optimization: All sections generated")\n        \n        return {\n            'sections': sections,\n            'optimization_metadata': {\n                'job_title': job_analysis.job_title,\n                'target_keywords': job_analysis.technical_keywords[:10],\n                'optimization_focus': resume_analysis.get('improvement_priority', []),\n                'generation_timestamp': datetime.now().isoformat()\n            }\n        }\n    \n    def _generate_optimized_summary(self, candidate_data: Dict, job_analysis: JobAnalysis, \n                                  resume_analysis: Dict) -> str:\n        """Generate ATS-optimized professional summary."""\n        resume_data = candidate_data.get('resume', {})\n        \n        prompt = f"""\n        You are a Senior Resume Writer specializing in ATS-optimized professional summaries.\n        \n        Create a compelling 2-3 sentence professional summary that:\n        \n        Target Job: {job_analysis.job_title} ({job_analysis.seniority_level} level)\n        Industry: {job_analysis.industry}\n        Required Skills: {', '.join(job_analysis.required_skills[:5])}\n        Key Keywords: {', '.join(job_analysis.technical_keywords[:8])}\n        \n        Current Experience: {json.dumps(resume_data.get('experience', [])[:2], indent=2)}\n        Current Skills: {', '.join(resume_data.get('skills', [])[:10])}\n        \n        Requirements:\n        - Include exact job title "{job_analysis.job_title}" naturally\n        - Integrate 4-5 top keywords: {', '.join(job_analysis.technical_keywords[:5])}\n        - Mention years of experience if relevant\n        - Highlight 2-3 key achievements/value propositions\n        - 40-80 words total (ATS optimal length)\n        - Professional, confident tone\n        - Quantify impact where possible\n        \n        Return ONLY the professional summary text, no additional formatting or explanation.\n        """\n        \n        try:\n            response = self.client.chat.completions.create(\n                model=self.model,\n                messages=[\n                    {"role": "system", "content": "You are a world-class resume writer. Create ATS-optimized professional summaries that get results."},\n                    {"role": "user", "content": prompt}\n                ],\n                temperature=0.4,\n                timeout=30\n            )\n            \n            return response.choices[0].message.content.strip()\n            \n        except Exception as e:\n            self.logger.error(f"Summary generation failed: {str(e)}")\n            return f"Experienced {job_analysis.job_title} with expertise in {', '.join(job_analysis.required_skills[:3])}. Proven track record of delivering results and driving organizational success."\n    \n    def _generate_optimized_skills(self, candidate_data: Dict, job_analysis: JobAnalysis, \n                                 resume_analysis: Dict) -> Dict:\n        """Generate ATS-optimized skills section."""\n        current_skills = candidate_data.get('resume', {}).get('skills', [])\n        \n        prompt = f"""\n        You are a Skills Optimization Specialist for ATS systems.\n        \n        Optimize the skills section for maximum ATS impact:\n        \n        Target Job Requirements:\n        - Required Skills: {', '.join(job_analysis.required_skills)}\n        - Preferred Skills: {', '.join(job_analysis.preferred_skills)}\n        - Technical Keywords: {', '.join(job_analysis.technical_keywords)}\n        - Soft Skills: {', '.join(job_analysis.soft_skills)}\n        \n        Current Skills: {', '.join(current_skills)}\n        \n        Create optimized skills categories in JSON format:\n        {{\n            "technical_skills": ["skill1", "skill2", ...],\n            "tools_technologies": ["tool1", "tool2", ...],\n            "soft_skills": ["skill1", "skill2", ...],\n            "certifications": ["cert1", "cert2", ...]\n        }}\n        \n        Rules:\n        - Prioritize exact keyword matches from job requirements\n        - Include variations of key skills (e.g., "Python", "Python Programming")\n        - Maximum 8 skills per category\n        - Use exact terminology from job description\n        - Balance technical and soft skills\n        - Include industry-standard tools/technologies\n        \n        Return ONLY valid JSON.\n        """\n        \n        try:\n            response = self.client.chat.completions.create(\n                model=self.model,\n                messages=[\n                    {"role": "system", "content": "You are an expert in ATS skills optimization. Create perfectly categorized, keyword-rich skills sections."},\n                    {"role": "user", "content": prompt}\n                ],\n                temperature=0.3,\n                timeout=30\n            )\n            \n            return self._parse_json_response(response.choices[0].message.content)\n            \n        except Exception as e:\n            self.logger.error(f"Skills generation failed: {str(e)}")\n            return {\n                "technical_skills": current_skills[:8],\n                "tools_technologies": [],\n                "soft_skills": ["Communication", "Leadership", "Problem Solving"],\n                "certifications": []\n            }\n    \n    def _generate_optimized_experience(self, candidate_data: Dict, job_analysis: JobAnalysis, \n                                     resume_analysis: Dict) -> List[Dict]:\n        """Generate ATS-optimized experience section."""\n        current_experience = candidate_data.get('resume', {}).get('experience', [])\n        \n        optimized_experience = []\n        \n        for i, exp in enumerate(current_experience[:4]):  # Max 4 experiences for one page\n            prompt = f"""\n            You are a Senior Career Strategist specializing in achievement-focused job descriptions.\n            \n            Optimize this work experience for the target role:\n            \n            Target Job: {job_analysis.job_title}\n            Key Keywords: {', '.join(job_analysis.technical_keywords[:10])}\n            Required Skills: {', '.join(job_analysis.required_skills[:8])}\n            Responsibilities: {', '.join(job_analysis.responsibilities[:5])}\n            \n            Current Experience Entry:\n            {json.dumps(exp, indent=2)}\n            \n            Create optimized experience entry in JSON format:\n            {{\n                "company": "{exp.get('company', 'Company')}",\n                "title": "{exp.get('title', 'Position')}",\n                "start_date": "{exp.get('start_date', '')}",\n                "end_date": "{exp.get('end_date', 'Present')}",\n                "location": "{exp.get('location', '')}",\n                "bullet_points": [\n                    "â€¢ Achievement 1 with quantified results",\n                    "â€¢ Achievement 2 with impact metrics",\n                    "â€¢ Achievement 3 with keyword integration"\n                ]\n            }}\n            \n            Rules for bullet points:\n            - Start with strong action verbs (Led, Developed, Implemented, Achieved)\n            - Include quantified results (percentages, numbers, metrics)\n            - Integrate 2-3 keywords from target job naturally\n            - Maximum 3 bullet points per position\n            - Focus on achievements, not just responsibilities\n            - Use past tense for previous roles, present for current\n            - Each bullet: 1-2 lines maximum\n            \n            Return ONLY valid JSON.\n            """\n            \n            try:\n                response = self.client.chat.completions.create(\n                    model=self.model,\n                    messages=[\n                        {"role": "system", "content": "You are an expert in writing achievement-focused job descriptions. Create compelling experience entries with quantified results."},\n                        {"role": "user", "content": prompt}\n                    ],\n                    temperature=0.4,\n                    timeout=30\n                )\n                \n                optimized_exp = self._parse_json_response(response.choices[0].message.content)\n                optimized_experience.append(optimized_exp)\n                \n            except Exception as e:\n                self.logger.error(f"Experience optimization failed for entry {i}: {str(e)}")\n                # Keep original if optimization fails\n                optimized_experience.append(exp)\n        \n        return optimized_experience\n    \n    def _generate_optimized_education(self, candidate_data: Dict, job_analysis: JobAnalysis) -> List[Dict]:\n        """Generate optimized education section."""\n        education_data = candidate_data.get('resume', {}).get('education', [])\n        \n        # For education, minimal optimization needed - just clean formatting\n        optimized_education = []\n        for edu in education_data[:2]:  # Max 2 education entries\n            optimized_edu = {\n                'institution': edu.get('institution', ''),\n                'degree': edu.get('degree', ''),\n                'field': edu.get('field', ''),\n                'graduation_year': edu.get('graduation_year', ''),\n                'gpa': edu.get('gpa', '') if float(edu.get('gpa', 0)) >= 3.5 else '',\n                'relevant_coursework': edu.get('relevant_coursework', [])\n            }\n            optimized_education.append(optimized_edu)\n        \n        return optimized_education\n    \n    def _ats_compliance_agent(self, optimized_content: Dict, job_analysis: JobAnalysis) -> Dict:\n        """Agent 4: Ensure ATS compliance and keyword optimization."""\n        start_time = time.time()\n        \n        # Analyze keyword density\n        content_text = self._extract_text_from_content(optimized_content)\n        keyword_analysis = self._analyze_keyword_density(content_text, job_analysis)\n        \n        # Apply ATS compliance rules\n        ats_compliant_content = self._apply_ats_standards(optimized_content, keyword_analysis)\n        \n        self.agent_timings['ats_compliance'] = time.time() - start_time\n        self.logger.info(f"ðŸŽ¯ ATS Compliance: {keyword_analysis['match_score']}/100 keyword match")\n        \n        return {\n            'content': ats_compliant_content,\n            'ats_analysis': keyword_analysis,\n            'compliance_score': self._calculate_compliance_score(ats_compliant_content)\n        }\n    \n    def _quality_assurance_agent(self, ats_content: Dict, job_analysis: JobAnalysis, \n                               candidate_data: Dict) -> Tuple[Dict, ResumeMetrics]:\n        """Agent 5: Final quality review and metrics calculation."""\n        start_time = time.time()\n        \n        final_content = ats_content['content']\n        \n        # Calculate comprehensive metrics\n        metrics = ResumeMetrics()\n        metrics.ats_score = ats_content['compliance_score']\n        metrics.keyword_match_score = ats_content['ats_analysis']['match_score']\n        \n        # Word count analysis\n        total_text = self._extract_text_from_content(final_content)\n        word_count = len(total_text.split())\n        metrics.estimated_word_count = word_count\n        metrics.one_page_compliance = word_count <= self.ats_standards['max_word_count']\n        \n        # Content quality analysis\n        metrics.content_quality_score = self._analyze_content_quality(final_content)\n        metrics.format_compliance_score = self._analyze_format_compliance(final_content)\n        \n        # Job relevance analysis\n        metrics.job_relevance_score = self._calculate_job_relevance(\n            final_content, job_analysis\n        )\n        \n        # Generate improvement recommendations\n        metrics.improvement_areas = self._generate_improvement_areas(\n            final_content, ats_content['ats_analysis']\n        )\n        \n        metrics.strengths = self._identify_strengths(final_content, job_analysis)\n        \n        self.agent_timings['quality_assurance'] = time.time() - start_time\n        self.logger.info(f"ðŸ” Quality Assurance: {metrics.content_quality_score}/100 quality score")\n        \n        # Prepare final resume structure\n        final_resume = {\n            'sections': final_content['sections'],\n            'metadata': {\n                'generation_time': time.time() - self.generation_start_time,\n                'agent_timings': self.agent_timings,\n                'target_job': job_analysis.job_title,\n                'optimization_level': 'advanced',\n                'ats_version': '2025'\n            },\n            'formatting_rules': self.ats_standards\n        }\n        \n        return final_resume, metrics\n    \n    def _extract_text_from_content(self, content: Dict) -> str:\n        """Extract all text content for analysis."""\n        text_parts = []\n        \n        sections = content.get('sections', {})\n        \n        # Professional summary\n        if sections.get('professional_summary'):\n            text_parts.append(sections['professional_summary'])\n        \n        # Skills\n        skills = sections.get('skills', {})\n        for category, skill_list in skills.items():\n            if isinstance(skill_list, list):\n                text_parts.extend(skill_list)\n        \n        # Experience\n        experiences = sections.get('experience', [])\n        for exp in experiences:\n            if exp.get('title'):\n                text_parts.append(exp['title'])\n            if exp.get('company'):\n                text_parts.append(exp['company'])\n            for bullet in exp.get('bullet_points', []):\n                text_parts.append(bullet)\n        \n        # Education\n        educations = sections.get('education', [])\n        for edu in educations:\n            for field in ['degree', 'institution', 'field']:\n                if edu.get(field):\n                    text_parts.append(edu[field])\n        \n        return ' '.join(text_parts)\n    \n    def _analyze_keyword_density(self, content_text: str, job_analysis: JobAnalysis) -> Dict:\n        """Analyze keyword density for ATS optimization."""\n        content_lower = content_text.lower()\n        \n        # Check required keywords\n        required_keywords = job_analysis.required_skills + job_analysis.technical_keywords\n        keyword_matches = []\n        \n        for keyword in required_keywords:\n            if keyword.lower() in content_lower:\n                keyword_matches.append(keyword)\n        \n        match_score = min(100, int((len(keyword_matches) / max(len(required_keywords), 1)) * 100))\n        \n        return {\n            'total_keywords': len(required_keywords),\n            'matched_keywords': keyword_matches,\n            'match_count': len(keyword_matches),\n            'match_score': match_score,\n            'missing_keywords': [k for k in required_keywords if k.lower() not in content_lower],\n            'keyword_density': len(keyword_matches) / max(len(content_text.split()), 1) * 100\n        }\n    \n    def _apply_ats_standards(self, content: Dict, keyword_analysis: Dict) -> Dict:\n        """Apply 2025 ATS standards to content."""\n        # Ensure one-page compliance\n        sections = content.get('sections', {})\n        \n        # Limit experience entries\n        if 'experience' in sections:\n            sections['experience'] = sections['experience'][:4]\n            \n            # Limit bullet points per job\n            for exp in sections['experience']:\n                if 'bullet_points' in exp:\n                    exp['bullet_points'] = exp['bullet_points'][:3]\n        \n        # Optimize skills categories\n        if 'skills' in sections:\n            skills = sections['skills']\n            for category in skills:\n                if isinstance(skills[category], list):\n                    skills[category] = skills[category][:8]\n        \n        return {'sections': sections}\n    \n    def _calculate_compliance_score(self, content: Dict) -> int:\n        """Calculate ATS compliance score."""\n        score = 100\n        sections = content.get('sections', {})\n        \n        # Check required sections\n        required_sections = ['professional_summary', 'experience', 'skills', 'education']\n        missing_sections = [s for s in required_sections if s not in sections]\n        score -= len(missing_sections) * 20\n        \n        # Check content quality\n        if sections.get('professional_summary'):\n            summary_words = len(sections['professional_summary'].split())\n            if not (40 <= summary_words <= 80):\n                score -= 10\n        \n        # Check experience formatting\n        experiences = sections.get('experience', [])\n        if len(experiences) > 4:\n            score -= 5\n        \n        for exp in experiences:\n            bullets = exp.get('bullet_points', [])\n            if len(bullets) > 3:\n                score -= 5\n        \n        return max(0, score)\n    \n    def _analyze_content_quality(self, content: Dict) -> int:\n        """Analyze content quality score."""\n        score = 80  # Base score\n        \n        sections = content.get('sections', {})\n        \n        # Check for quantified achievements\n        experiences = sections.get('experience', [])\n        quantified_count = 0\n        \n        for exp in experiences:\n            for bullet in exp.get('bullet_points', []):\n                if re.search(r'\\d+[%$]?|\\b\\d+\\b', bullet):\n                    quantified_count += 1\n        \n        score += min(20, quantified_count * 5)\n        \n        return min(100, score)\n    \n    def _analyze_format_compliance(self, content: Dict) -> int:\n        """Analyze format compliance with 2025 standards."""\n        score = 100\n        \n        # Check structure compliance\n        sections = content.get('sections', {})\n        \n        # Verify all required sections exist\n        required = ['professional_summary', 'skills', 'experience', 'education']\n        for section in required:\n            if section not in sections:\n                score -= 25\n        \n        return max(0, score)\n    \n    def _calculate_job_relevance(self, content: Dict, job_analysis: JobAnalysis) -> int:\n        """Calculate job relevance score."""\n        content_text = self._extract_text_from_content(content)\n        \n        # Count relevant keywords\n        relevant_keywords = (\n            job_analysis.required_skills + \n            job_analysis.technical_keywords + \n            job_analysis.responsibilities\n        )\n        \n        relevance_count = 0\n        for keyword in relevant_keywords:\n            if keyword.lower() in content_text.lower():\n                relevance_count += 1\n        \n        return min(100, int((relevance_count / max(len(relevant_keywords), 1)) * 100))\n    \n    def _generate_improvement_areas(self, content: Dict, ats_analysis: Dict) -> List[str]:\n        """Generate specific improvement recommendations."""\n        improvements = []\n        \n        if ats_analysis['match_score'] < 75:\n            improvements.append(f"Add missing keywords: {', '.join(ats_analysis['missing_keywords'][:3])}")\n        \n        if len(ats_analysis['missing_keywords']) > 5:\n            improvements.append("Increase keyword density for better ATS matching")\n        \n        # Check word count\n        total_text = self._extract_text_from_content(content)\n        word_count = len(total_text.split())\n        \n        if word_count > 600:\n            improvements.append("Reduce content length for one-page compliance")\n        \n        return improvements[:5]  # Top 5 improvements\n    \n    def _identify_strengths(self, content: Dict, job_analysis: JobAnalysis) -> List[str]:\n        """Identify resume strengths."""\n        strengths = []\n        \n        sections = content.get('sections', {})\n        \n        # Check for quantified achievements\n        experiences = sections.get('experience', [])\n        for exp in experiences:\n            for bullet in exp.get('bullet_points', []):\n                if re.search(r'\\d+[%$]?', bullet):\n                    strengths.append("Contains quantified achievements")\n                    break\n        \n        # Check keyword integration\n        content_text = self._extract_text_from_content(content)\n        matched_skills = 0\n        for skill in job_analysis.required_skills:\n            if skill.lower() in content_text.lower():\n                matched_skills += 1\n        \n        if matched_skills >= 5:\n            strengths.append("Strong keyword alignment with job requirements")\n        \n        return list(set(strengths))  # Remove duplicates\n    \n    def _calculate_final_ats_score(self, resume: Dict, job_analysis: JobAnalysis) -> int:\n        """Calculate final comprehensive ATS score."""\n        content_text = self._extract_text_from_content(resume)\n        \n        # Keyword matching (40% weight)\n        keyword_score = self._analyze_keyword_density(content_text, job_analysis)['match_score']\n        \n        # Format compliance (20% weight)\n        format_score = self._analyze_format_compliance(resume)\n        \n        # Content quality (20% weight)\n        content_score = self._analyze_content_quality(resume)\n        \n        # Job relevance (20% weight)\n        relevance_score = self._calculate_job_relevance(resume, job_analysis)\n        \n        final_score = int(\n            keyword_score * 0.4 + \n            format_score * 0.2 + \n            content_score * 0.2 + \n            relevance_score * 0.2\n        )\n        \n        return min(100, final_score)\n    \n    def _parse_json_response(self, response_text: str) -> Dict:\n        """Safely parse JSON response from LLM."""\n        try:\n            # Clean markdown code blocks\n            cleaned = response_text.strip()\n            cleaned = re.sub(r'```json\\s*', '', cleaned)\n            cleaned = re.sub(r'```\\s*$', '', cleaned)\n            cleaned = cleaned.strip()\n            \n            return json.loads(cleaned)\n        except json.JSONDecodeError as e:\n            self.logger.error(f"JSON parsing failed: {str(e)}")\n            return {}\n\n# Usage example\nif __name__ == "__main__":\n    generator = AdvancedResumeGenerator()\n    \n    # Example candidate data\n    candidate_data = {\n        'resume': {\n            'skills': ['Python', 'JavaScript', 'React'],\n            'experience': [\n                {\n                    'title': 'Software Engineer',\n                    'company': 'Tech Corp',\n                    'start_date': '2022',\n                    'end_date': 'Present',\n                    'description': 'Developed web applications using modern frameworks.'\n                }\n            ],\n            'education': [\n                {\n                    'degree': 'Bachelor of Science',\n                    'institution': 'University',\n                    'field': 'Computer Science',\n                    'graduation_year': '2022'\n                }\n            ]\n        },\n        'personal_info': {\n            'name': 'John Doe',\n            'email': 'john.doe@email.com',\n            'phone': '(555) 123-4567'\n        }\n    }\n    \n    job_description = """\n    Senior Software Engineer - Python/React\n    \n    We are seeking a talented Senior Software Engineer to join our growing team.\n    \n    Requirements:\n    - 3+ years of Python development experience\n    - Strong React and JavaScript skills\n    - Experience with cloud platforms (AWS, GCP)\n    - Leadership and mentoring abilities\n    """\n    \n    # Generate optimized resume\n    optimized_resume, metrics = generator.generate_optimized_resume(\n        candidate_data, job_description\n    )\n    \n    print(f"âœ… Resume generated with ATS score: {metrics.ats_score}/100")\n    print(f"ðŸ“Š Word count: {metrics.estimated_word_count}")\n    print(f"ðŸ“„ One-page compliant: {metrics.one_page_compliance}")